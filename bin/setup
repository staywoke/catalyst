#!/usr/bin/env ruby

require 'yaml'
require 'json'
require 'open-uri'
require 'openssl'
require 'open3'

DEPENDENCIES = [
  {
    name: 'docker',
    min_version: '1.12.1',
    version_command: %w[docker -v],
  },
  {
    name: 'docker-compose',
    min_version: '1.8.0',
    version_command: %w[docker-compose -v],
  },
]

def symlink_docker_compose_override
  return if File.exist?('docker-compose.override.yml')
  File.symlink('docker-compose.override.example.yml', 'docker-compose.override.yml')
end

def system!(*args)
  system(*args) or exit($?.exitstatus)
end

def capture!(*args)
  out, pinfo = Open3.capture2e(*args)
  unless pinfo.success?
    warn "Failed to execute #{args.inspect}. Output follows:\n#{out}"
    fail MissingDependencyError, d[:name]
  end
  out
end

def assert_version_gte(expected, actual)
  String(expected).split(/[.-]/).zip(String(actual).split(/[.-]/)).each do |(expected_part, actual_part)|
    len = [expected_part, actual_part].map(&:length).max
    if (expected_part.rjust(len) <=> actual_part.rjust(len)) > 0
      fail "#{actual} !>= #{expected}"
    end
  end
end

def assert_dependencies
  pass = true
  DEPENDENCIES.each do |d|
    begin
      out = capture!(*d[:version_command])
      assert_version_gte d[:min_version], d.fetch(:version_pattern, /\d+\.\d+\.\d+/).match(out)
    rescue => ex
      warn "Error verifying dependency #{d[:name]}: #{ex.inspect}"
      pass = false
    end
  end
  fail 'A required dependency is missing.' unless pass
end

def docker_compose_config
  @compose_config ||= YAML.load(`docker-compose config`)
end

def list_containers_for_service(service_name)
  project = ENV['COMPOSE_PROJECT_NAME'].downcase.gsub(/[^a-z0-9]+/, '')

  `docker ps \
     --filter "label=com.docker.compose.project=#{project}" \
     --filter "label=com.docker.compose.service=#{service_name}" \
     --filter "label=com.docker.compose.oneoff=False" -q`.chomp.split
end

def container_is_dead?(service_name)
  list_containers_for_service(service_name).none?
end

def wait_for_db_to_be_ready
  print 'Waiting for DB to become ready: '
  loop do
    putc ?.
    log = `docker-compose logs --tail=30 db`
    break if /LOG:  database system is ready to accept connections/.match(log)

    if container_is_dead?('db')
      fail 'DB container died :-( -- check the logs: docker-compose logs db'
    end

    sleep 1
  end
ensure
  putc "\n"
end

def prepare_database
  system(*%w[ docker-compose up -d db ]) or exit($?.exitstatus)
  wait_for_db_to_be_ready
  system(*%w[ docker-compose run --rm app rake --trace db:safe_setup ]) or exit($?.exitstatus)
end

def start_the_app
  system 'docker-compose', 'up', '-d', 'app' or exit($?.exitstatus)
  system 'docker-compose', 'up', '-d', 'worker' or exit($?.exitstatus)
end

def prepare_images
  system 'docker-compose', 'build' or exit($?.exitstatus)
  system 'docker-compose', 'pull', '--ignore-pull-failures' or exit($?.exitstatus)
end

def wait_for_app_to_be_ready(time_to_wait=30)
  start_time = Time.now
  health_endpoint = app_url
  warn "Waiting up to #{time_to_wait}s for the App to become ready (querying #{health_endpoint} ..."
  begin
    res = open(health_endpoint, ssl_verify_mode: OpenSSL::SSL::VERIFY_NONE)
    status = res.status.first.to_i
    status == 200 or fail "response status #{status} != 200"
  rescue => ex
    if Time.now >= start_time + time_to_wait
      require 'pry'
      binding.pry
      raise
    end
    warn "Error while polling app: #{ex.class.name}: #{ex.message.gsub("\n", " ")[0, 200]}..."
    sleep 1
    retry
  end
  warn 'App is ready!'
end

def app_url
  URI(docker_compose_config['services']['app']['environment']['EXTERNAL_URL'])
end

def open_app_in_browser
  res = system 'xdg-open', app_url.to_s
  if res.nil? # error with spawn, i.e. command not found, try OSX's `open`
    system 'open', app_url.to_s
  end
end

symlink_docker_compose_override
assert_dependencies
prepare_images
prepare_database
start_the_app
wait_for_app_to_be_ready
open_app_in_browser

exec 'docker-compose', 'logs', '-f', 'app'
